---
date: 2018-12-17
status: draft
tags: ARTS
title: ARTS(10)
---

# 1 Algorithm
设计一个`LRU`缓存机制，使它支持`put`和`get`操作，缓存大小是由一定限制的，如果缓存数量超出范围，则删除最近最少使用的`key`，如果`key` 不存在，返回`-1`（所有的`value`值大于0）。
借助一个数组`keys`保存所有`key`使用的顺序，一旦更新使用了该`key`，将其
```go
type LRUCache struct {
	table    map[int]int
	keys     []int
	capacity int
}

func Constructor(capacity int) LRUCache {
	return LRUCache{
		table:    make(map[int]int, 0),
		keys:     make([]int, 0, capacity),
		capacity: capacity,
	}
}

func (this *LRUCache) Get(key int) int {
	if val, ok := this.table[key]; ok {
		pivot := this.pivot(key)
		this.keys = append(append(this.keys[0:pivot], this.keys[pivot+1:len(this.keys)]...), key)
		return val
	}
	return -1
}

func (this *LRUCache) pivot(key int) int {
	for idx, k := range this.keys {
		if k == key {
			return idx
		}
	}
	return -1
}
func (this *LRUCache) Put(key int, value int) {
	if _, ok := this.table[key]; ok {
		// delete exisiting key
		pivot := this.pivot(key)
		this.keys = append(this.keys[0:pivot], this.keys[pivot+1:len(this.keys)]...)
	}
	if len(this.keys) < this.capacity {
		this.keys = append(this.keys, key)
		this.table[key] = value
	} else {
		delete(this.table, this.keys[0])
		this.keys = append(this.keys[1:this.capacity], key)
		this.table[key]= value
	}
}
```
# 2 Review
# 3 Tips
# 4 Share