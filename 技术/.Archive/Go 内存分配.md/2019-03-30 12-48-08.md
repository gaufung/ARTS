---
title: Go 内存分配
date: 2019-03-25
status: public
---

# 1 基础概念
内存分配是所有编程语言的重点考虑的内容，通常这些是由运行时（`runtime`) 进行管理，以此来达到内存池，可复用和避免碎片化等目的。在 `Golang`  内存分配算法基于 [tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)。
## 1.1 基础结构
在 `src/runtime` 目录下，包含了全部的内存分配的相关结构，最主要的结构主要有 `mspan`, `mcache`, `mcentral` 和 `mheap`。
```go
type mspan struct {
    next     *mspan    // in a span linked list
	prev     *mspan    // in a span linked list
	start    pageID    // starting page number
	npages   uintptr   // number of pages in span
	freelist gclinkptr // list of free objects
	//....
}
```
`mspan` 是由地址连续的页组成，在 `Golang` 中每个页大小为 `8KB`
```go
_PageShift = 13
_PageSize = 1 << _PageShift
```
`mspan` 是一个双向链表，用以分配对象的 `object`, 按照 8  字节划分为 n 种, 比如大小为 24 的 `object` 可以存储 `17-24` 字节的对象。虽然会浪费一些空间，但是方便管理，并且避免的更大的碎片化。
按照对象的大小，全局分配了 67 中不同的大小类别，对于超出一定阈值的对象 `32KB`，当做大对象处理。
```go
_NumSizeClass = 67
_MaxSmallSize = 32 << 10 // 32KB
```
mheap 是内存的表示
```go
_MaxMHeapList   = 1 << (20 - _PageShift)  // 127
type mheap struct {
    free      [_MaxMHeapList]mspan // free lists of given length
	freelarge mspan                // free lists length >= _MaxMHeapList
	busy      [_MaxMHeapList]mspan // busy lists of large objects of given length
	busylarge mspan                // busy lists of large objects length >= _MaxMHeapList
	central [_NumSizeClasses] struct {
	    mcentral mcentral
	}
}
```
mcentral 是中间过程表示
```go
type mcentral struct {
	lock      mutex
	sizeclass int32
	nonempty  mspan // list of spans with a free object
	empty     mspan // list of spans with no free objects (or cached in an mcache)
}
```
mcache 对于每一个 `goroutine`, 这也是 `tcmalloc` 的核心高效的核心所在，每个`goroutine` 都拥有一个 `macache`, 避免了内存分配过程中的加锁，大大提高了效率。
```go
type mcache struct {
	alloc [_NumSizeClasses]*mspan // spans to allocate from
}
```
整体的示意图如下
![](./_image/2019-03-30-10-06-19.jpg)

 # 2 分配过程
## 2.1 初始化
在初始化阶段，预先保留了一段虚拟地址空间，空间被划分为三个区域
```
+-----------------+----------------------+----------------------------+
| spans 512MB  |    bitmap 32GB      |     area 512GB                 |
+-----------------+----------------------+----------------------------+
```
这些信息保存在 heap 中，
```go
type mheap struct {
    spans  **mspan
    spans_mapped uintptr
    
    bitmap uintptr
    bitmap_mapped uintptr
    
    area_start  uintptr
    area_used uintptr
    area_end uintptr
    area_reseverd bool
}
```
`mallocinit` 函数通过调用操作系统相关的 `mmap` 申请虚拟空间，在此期间也调用 `mHeap_Init` 函数初始化 `mheap` 中的各种 `mspan` 链表。

## 2.2 分配
所有的内存分配都会调用 `newobject` 方法
```go
func newobject(typ *_type) unsafe.Pointer {
	flags := uint32(0)
	if typ.kind&kindNoPointers != 0 {
		flags |= flagNoScan
	}
	return mallocgc(uintptr(typ.size), typ, flags)
}
```
`flagNoScan` 表明这个对象没有指针，因为接下来对于不包含指针的对象有单独的处理。接下来所有的工作交给了 `mallocgc` 函数
```go
func mallocgc(size uintptr, typ *_type, flags uint32) unsafe.Pointer{
    if size == 0 {
		return unsafe.Pointer(&zerobase)
	}
	if size <= maxSmallSize {
		if flags&flagNoScan != 0 && size < maxTinySize {
			off := c.tinyoffset
			if off+size <= maxTinySize && c.tiny != nil {
				// The object fits into existing tiny block.
				x = add(c.tiny, off)
				c.tinyoffset = off + size
				c.local_tinyallocs++
				mp.mallocing = 0
				releasem(mp)
				return x
			}
			// Allocate a new maxTinySize block.
			s = c.alloc[tinySizeClass]
			v := s.freelist
			if v.ptr() == nil {
				systemstack(func() {
					mCache_Refill(c, tinySizeClass)
				})
				shouldhelpgc = true
				s = c.alloc[tinySizeClass]
				v = s.freelist
			}
			s.freelist = v.ptr().next
			s.ref++
			// prefetchnta offers best performance, see change list message.
			prefetchnta(uintptr(v.ptr().next))
			x = unsafe.Pointer(v)
			(*[2]uint64)(x)[0] = 0
			(*[2]uint64)(x)[1] = 0
			// See if we need to replace the existing tiny block with the new one
			// based on amount of remaining free space.
			if size < c.tinyoffset {
				c.tiny = x
				c.tinyoffset = size
			}
			size = maxTinySize
		} else {
			var sizeclass int8
			if size <= 1024-8 {
				sizeclass = size_to_class8[(size+7)>>3]
			} else {
				sizeclass = size_to_class128[(size-1024+127)>>7]
			}
			size = uintptr(class_to_size[sizeclass])
			s = c.alloc[sizeclass]
			v := s.freelist
			if v.ptr() == nil {
				systemstack(func() {
					mCache_Refill(c, int32(sizeclass))
				})
				shouldhelpgc = true
				s = c.alloc[sizeclass]
				v = s.freelist
			}
			s.freelist = v.ptr().next
			s.ref++
			// prefetchnta offers best performance, see change list message.
			prefetchnta(uintptr(v.ptr().next))
			x = unsafe.Pointer(v)
			if flags&flagNoZero == 0 {
				v.ptr().next = 0
				if size > 2*ptrSize && ((*[2]uintptr)(x))[1] != 0 {
					memclr(unsafe.Pointer(v), size)
				}
			}
		}
		c.local_cachealloc += size
	} else {
		var s *mspan
		shouldhelpgc = true
		systemstack(func() {
			s = largeAlloc(size, uint32(flags))
		})
		x = unsafe.Pointer(uintptr(s.start << pageShift))
		size = uintptr(s.elemsize)
	}
}
```
首先是 `size == 0` 特殊处理，所以下面等式是成立的
```go
type T struct {}
a, b := new(T), new(T)
fmt.Sprintf("%p", a) == fmt.Spritf("%p", b) // true
```
整体思路是
- 微小对象（16），采用 cache.tiny object 分配
- 小对象（128）， 使用`cache.alloc[sizeclass].freelist` 分配
- 大对象直接从heap 中分配

小对象首先尝试从`cache.tiny + cache.off` 中分配，如果空间足够，则继续按照`size`， 增加 `cache.off` 来分配内存，否则从 `cache.alloc[tinySizeClass]` 也就是 `cache.alloc[2]` 中获取相应的 `mspan` 的 `freelist`， 如果 `cache.alloc[2]` 也没有空闲的`mspan`, 那就调用 `mCache_Refill` 方法从 `mcentral` 中获取。
对于普通的对象，首先根据对象大小计算出 `sizeclass`，然后从 `cache`  中获取相应的`freelist`，如果出现空间不够，调用 `mCache_Refill` 来完成空间申请。
最后大对象申请就比较简单了，直接调用 `largeAlloc` 函数从空间中申请即可。

## 2.3 扩张
如果 `mcahe` 中的空间不够了， 调用`mcache_Refill` 方法来扩张
```go
	s := c.alloc[sizeclass]
	// Get a new cached span from the central lists.
	s = mCentral_CacheSpan(&mheap_.central[sizeclass].mcentral)
	c.alloc[sizeclass] = s
	return s
```
用 `mCetneral_CacehSpan` 中获取新的 `mspan` 来替换原先的`c.alloc[sizeclass]` 中的 `mspan`。
过程很简单，首先遍历 `mcentral` 中的 `noempty` 链表，查看可以使用的`mspan`, 如果没有过从`empty`中遍历，获得那些已经清空的`mspan`。如果还是没有有用的`mspan`， 从`mCentral_Grow` 函数从 `heap` 中获取新的`mspan`, 然后将它添加到 `mcentral`中 `noempty` 链表中。
# 3 回收过程

# 4 参考
