---
date: 2019-05-19
status: public
tags: ARTS
title: ARTS(31)
---

# 1 Algorithm

> 给定一个 `IPv4` 地址的字符串，将其转换为 `int` 表示的整数，需要考虑不合法的字符串，只能使用常数空间。比如字符串 `127.0.0.1` 表示一个 `IPv4`地址，每一段都是 `byte` 表示的整数，四个 `byte` 可以表示 32 位的整数 `2130706433`。

首先对字符串按字符 `.` 划分为四个部分，在将其转换为整数，然后依次左移 `24`, `16`, `8` 和 `0` 位，将这些左移后的结果按照**或**(`|`)操作完整整数转换。那么不合法的情况有哪些呢？

- 合法的 `IPv4` 地址每一段的范围只能是 $[0, 255]$；
- 按照 `.` 划分只能划分为四个部分；
- 字符串只能包含数字和 `.` 两种字符；
- `.` 不能连续两次出现，也不能出现在字符串首和尾。

```go
func IPv4ToInt(s string) (int, error) {
    i := 0
    dotCount := 0
    res := 0
    val : = 0
    for i < len(s) {
        if s[i] == '.'{
            if i==0 || (i>0 && s[i] == s[i-1]) || i == len(s)-1 {
                return 0, errors.New("invalid IPv4")
            }
            if dotCount >= 3 {
                 return 0, errors.New("invalid IPv4")
            }
            val = val << uint(8 * (3 - dotCount))
            res = res | val
            val = 0
            dotCount ++ 
        }else{
            if !(s[i] >= '0' &&s[i] <= '9') {
                return 0, errors.New("invalid IPv4")
            }
            val = val * 10 + int(s[i] - '0')
            if val > 255 {
                return 0, errors.New("invalid IPv4")
            }
        }
        i++
    }
     if val > 255 || dotCount > 3 {
        return 0, errors.New("invalid IPv4")
    }
    res = res | val
    return res, nil
}
```

# 2 Review

[Technical Debt](https://martinfowler.com/bliki/TechnicalDebt.html)

**技术债**

软件系统往往会构建在错误的设计上，内部质量的缺乏导致为系统修改和增加新的功能变得更加困难。技术债就是这种比喻，是由 `Ward Cunningham`提出来的，它用来形容我们如何处理这种错误的设计，就跟财务债务一样。我们为系统增加新功能而做的额外的工作就是为这些技术债付利息。

![debt](./_image/2019-05-22-11-31-44.jpg?r=60)

想象一下我代码库中有一个非常令人困惑的模块，但是我需要增加新的功能。如果这个模块结构非常清晰，那么需要花费我 4 天时间来完成工作。但是由于内部错误的设计，却需要花费我 6 天时间。这两天的的差别就是技术债的利息。

这个技术债的比喻最吸引我的地方时它告诉我如何处理这些错误的设计。我可能花费 5 天时间清理模块结构，移除不合理的实际，就像还清本金一样。如果我仅仅是为了一个功能，这样做没有任何收益，我将要怀峰 9 天而不是 6 天。但是如果接下来有更多相似的功能，在移除了不合理的设计之后，这些工作是非常快速地完成。

说是这样说，听上去好像仅仅是数字上运算的结果，任何经理都可以通过 Excel 来计算并得到选择。不幸的是我们并[不能计算生产效率](https://martinfowler.com/bliki/CannotMeasureProductivity.html)，上述的任何成本都不能客观测量。我们可以估计它需要完成功能需要多长时间；估计移除上述错误设计的影响；估计需要花多长时间来移除错误设计。但是我们估计的准确性非常低。

考虑到我们通常针对财务债务的方式一样，一步步偿清本金。在第一个功能的时候，我将会花费几天时间来移除一些错误设计，它可以减少在将来某一天的带来的*利息*。还需要花费额外的时间，但是通过移除那些将来改变的代码中不好的设计。这种渐进式提高的好处是我们可以花更多的时间在移除那些我们经常修改的模块中，它们也是我们代码库中我们需要被移除的不好设计的地方。

将付利息和付本金考虑对比考虑可以帮助我们决定那一部分的设计优先解决。如果我的代码库中有一个糟糕的部分，每一次修改都是一场噩梦，如果我没有一定要修改就没有问题。我仅仅是在不得不软件的中的一部分工作的时候，才需要引发支付利息（在这里比喻并不是非常精确，因为支付财务利息是由时间长短引发的）。虽然这部分代码如此糟糕，但是只要不管它也能相安无事。与此相反的是，经常性修改的代码需要零容忍的态度，因为为它们支付利息是非常高的。它们是非常重要的因为如果开发者不关注内部质量，这些错误设计就会累积起来，越多的改变，错误设计累积的风险越大

（未完待续）

# 3 Tips

Linux 文本处理

## 3.1 find 

查找 txt 和 pdf 文件：`find . \(-name "*.txt" -name "*.pdf" \) -print`

正则查找： `find . -regex ".*\(\.txt|\.pdf\)$`

否定参数，查找非 txt 文件： `find . ! -name "*.txt" -print`


# 4 Share