---
date: 2019-04-29
status: public
tags: ARTS
title: ARTS(28)
---

# 1 Algorithm
>设计一个实时数据流接收器，要求在任意时刻输出所有数据的中位数。

初步设计在内部维护一个有序队列，每接受一个数据，插入到这个有序队列中，时间复杂度为 $O(n^2)$。既然需要输出数据流的中位数，那么只需要维护好这个中位数即可，至于其他数据可以降低排序的顺序要求，所以我们可以借助堆 (`heap`) 这个数据结构。
![](./_image/2019-04-29-19-26-18.jpg)
将整个数据流划分到这个两个堆中，数据流的前半部分将构建最大堆，而后半分布构建最小堆。为了保证快速获取数据的中位数，保证这个两个堆的数据量相差不超过 1， 那么中位数必定最大堆的顶元素和最小堆顶元素中产生（或者取平均数），所以在接受数据流的时候，往最大堆和最小堆中依次插入数据，在插入数据后，比较最大堆和最小堆的顶元素，如何最大堆的的顶元素比最小堆的顶元素大，则交换这两个顶元素，保证局部的偏序性。
上图为堆的逻辑视图，堆完全可以使用数组保存，按照堆的层次存放到数组中，存在下面的两个性质：
- $i$ 节点的父节点为$\lfloor \frac{n-1}{2} \rfloor $
- $i$ 节点的孩子节点为 $2 i + 1$ 和 $2i + 2$

初始化一个堆，从最后位置依次比较它和其父节点的大小，如果不满足顺序关系，交换数据，如此迭代直到第一个元素，时间复杂度为 $O(n)$。
将一个数据插入到堆中，首先将它插入到数组的最后，比较其和父节点顺序关系，如果不满足则交换数据，然后继续往上比较，类似冒泡的形式，时间复杂度为 $O(log(n))$。
将一个顶层元素从堆中删除，首先将最后一个元素置于顶层，然后分别比较其余两个子节点比较，如果不满足则与其中一个交换，重复如此下去，最后直达底层，时间复杂度为 $O(log(n))$
## 1.1 堆实现
```go
type Heap struct {
	elements []int
	compare  func(int, int) bool
}

func NewHeap(compare func(int, int) bool) *Heap {
	return &Heap{
		elements: make([]int, 0),
		compare:  compare,
	}
}

func (h *Heap) heap() {
	i := len(h.elements) - 1
	for ; i > 0; i-- {
		j := (i - 1) / 2
		if j >= 0 && h.compare(h.elements[i], h.elements[j]) {
			h.elements[i], h.elements[j] = h.elements[j], h.elements[i]
		}
	}

}

func (h *Heap) upHeap() {
	i := len(h.elements) - 1
	for i > 0 {
		j := (i - 1) / 2
		if h.compare(h.elements[i], h.elements[j]) {
			h.elements[i], h.elements[j] = h.elements[j], h.elements[i]
			i = j
		} else {
			break
		}
	}
}

func (h *Heap) downHeap() {
	size := len(h.elements)
	i := 0
	for i < size {
		left, right := 2*i+1, 2*i+2
		if right < size {
			index := right
			if h.compare(h.elements[left], h.elements[right]) {
				index = left
			}
			if h.compare(h.elements[index], h.elements[i]) {
				h.elements[index], h.elements[i] = h.elements[i], h.elements[index]
				i = index
			} else {
				break
			}
		}else if left < size {
			if h.compare(h.elements[left], h.elements[i]) {
				h.elements[left], h.elements[i] = h.elements[i], h.elements[left]
				i = left
				continue
			} else {
				break
			}
		}else{
			break
		}
	}
}

func (h *Heap) Top() int {
	return h.elements[0]
}
func (h *Heap) Pop() int {
	val := h.Top()
	h.elements[0], h.elements[len(h.elements)-1] = h.elements[len(h.elements)-1], h.elements[0]
	h.elements = h.elements[:len(h.elements)-1]
	h.downHeap()
	return val
}

func (h *Heap) Push(val int) {
	h.elements = append(h.elements, val)
	h.upHeap()
}

func (h *Heap) Empty() bool {
	return len(h.elements) == 0
}
```
## 1.2 中位数
```go
type MedianFinder struct {
	minHeap *Heap
	maxHeap *Heap
	cnt     int
}

/** initialize your data structure here. */
func Constructor() MedianFinder {
	min := func(a, b int) bool { return a < b }
	max := func(a, b int) bool { return a > b }
	finder := MedianFinder{cnt: 0}
	finder.minHeap = NewHeap(min)
	finder.maxHeap = NewHeap(max)
	return finder
}

func (this *MedianFinder) AddNum(num int) {
	if this.cnt%2 == 0 {
		this.maxHeap.Push(num)
	} else {
		this.minHeap.Push(num)
	}
	this.cnt = this.cnt + 1
	if this.minHeap.Empty() || this.maxHeap.Empty() {
		return
	}
	min := this.minHeap.Top()
	max := this.maxHeap.Top()
	if max > min {
		this.minHeap.Pop()
		this.minHeap.Push(max)
		this.maxHeap.Pop()
		this.maxHeap.Push(min)
	}
}

func (this *MedianFinder) FindMedian() float64 {
	if this.cnt%2 == 0 {
		return (float64(this.minHeap.Top()) + float64(this.maxHeap.Top())) * 0.5
	} else {
		return float64(this.maxHeap.Top())
	}
}
```
# 2 Review
[Two Star Programming](http://wordaligned.org/articles/two-star-programming)
# 3 Tips

# 4 Share
