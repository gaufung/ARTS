---
title: 关系型数据库是怎么工作的？
status: draft
date:  2019-10-05
---

# 1 前言

当讨论到关系型数据库，我仍不住在想是不是有些东西已经忘了。从短小精悍的 SQLite 到强大的 Teradata，形形色色的关系型数据库广泛被使用，但是很少有文章去解释它们是如何工作的。你可以在 google 搜索框内输入 ”关系型数据库是如何工作的“ 来查看相应的结果，但是更多情况下都是都是非常短文章。现在如果你查看最新流行的技术（大数据，NoSQL 或者 JavaScript)，你会找到很多深入的文章来解释它们是如何工作的。

是不是关系型数据库它老旧了或者太无聊了，以至于除了大学教程、研究论文或者书籍之外都不愿意在讨论它了？

作为一个开发者，我**讨厌**使用我不理解的东西，而作为已经诞生 40 余年的关系型数据库，其中一定包含大量的奥秘。过去几年我花费了上百个小时来搞清楚这个每天使用的黑盒子的原理。关系型数据库非常有趣因为它建立在一些有用并且可重用的概念之上，如果你对理解数据库感兴趣但是没有时间或者意愿花大量的时间在这个主题上，你一定会喜欢这边文章。

尽管标题非常清晰，但是还是要强调这篇文章的目的并不是掌握如何使用数据库，因此你应当知道如何写一些简单的查询或者基本的 CRUD 操作，否则你将不会理解这篇文章。你只需要里了解这些，剩下的我都会一一解释。

我将以计算机科学中的时间复杂度概念展开，我知道你们其中可能会讨厌这个概念，但是没有它就不能理解数据库中的精妙之处。因为这是一个宏大的主题，我将专注于我认为比较重要的内容：数据库是如何处理 SQL 查询，在阅读完文章后可以查阅更多的相关的内容。

这篇文章非常长并且涉及了很多算法和数据结构，请保持耐心阅读。如果有些概念目前很难理解，可以尝试跳过它们，这并不妨碍你获得一个全局的印象。整个文章可以分为三个部分：

- 低层次和高层次数据库组成部分的概览
- 查询优化过程的概览
- 事务和缓冲池的概览

# 2 基础知识

无论什么时候，开发者都必须要知道他的代码会执行多少次操作，而且必须彻底的掌握使用的算法和数据结构，因为浪费 CPU 操作和内存是一件不可接受的事。在本小节中我会提及这些概念因为对理解数据库是非常重要的，尤其是在介绍数据库索引的概念的时候。

## 2.1 O(1) 和 O(n^2)

如今很多开发者并不关心时间复杂度，从某种意义上它们是正确的。但是当你处理大量数据或者为优化毫秒操作的时候，时间复杂度就变得非常重要了。对于数据库而言，这两种情况都是需要重点考虑的，尤其在理解基于成本数据库查询优化概念的时候非常重要。

### 2.1.1 概念

时间复杂度概念用来描述一个算法在给定的数据量情况下所花费的时间。为了描述这个复杂度，计算机科学家使用了数学概念中大 O 注记法，该方法使用函数来描述一个算法在给定数据量情况下该算法的操作数。举例来讲当我们说
> 这个算法是 O(some_function())

也就是说在给定数据量的输入条件下，需要 some_function(数据量) 的操作来完成任务。

重要的不是数据量大小，而是当数据量增加时需要操作数增加的方式。时间复杂度并不会给出确切的操作数而且大致的示意。

从上图中可以看到不同类型的时间复杂度演变，在这里我使用对数量级来绘制这张图，也就是说，数据量迅速从 1 增加到 10 亿，从中我们可以看到：

- O(1) 或者常数复杂度始终保持常数（否则就不会叫做常数复杂度）
- O(log(n)) 复杂度在 10 亿数量级还是保持很低
- 最差的时间复杂度是 O(n^2)，因为它操作数呈现爆炸式增长
- 剩余的时间复杂度的操作数也是迅速增加

### 2.1.2 示例

在低数量级别的时候，O(1) 和 O(n^2) 的差距是不明显，比如说假设你有一个算法处理 2000 元素：

- O(1) 算法需要花费 1 次操作
- O(log(n)) 算法需要花费 7 次操作
- O(n) 算法需要花费 2000 次操作
- O(n*log(n)) 算法需要花费 14000 次操作
- O(n^2) 算法需要花费 4000000 次操作

O(1) 和 O(n^2) 算法的区别看上去有点大（4 百万），但是实际上最多消耗 2 毫秒，也就是一眨眼的功夫，因为目前的处理器大概在每秒钟能够处理百万次操作，这也就是为什么在很多 IT 项目中性能和优化并不是问题。

但是正如说过，如果处理大量数据的时候就非常重要了。这一次算法需要处理 100000 个元素（对于数据库而言并不算是很大）。

- O(1) 算法需要花费 1 次操作
- O(log(n)) 算法需要花费 14 次操作
- O(n) 算法需要花费 1000000 次操作
- O(n*log(n)) 算法需要花费 14000000 次操作
- O(n^2) 算法需要花费 1000000000000 次操作

这一次没有做数学计算但是我可以说 O(n^2) 算法的操作时间可以去煮一杯咖啡了。如果你在输入数据后面增加一个 0，你可以去睡一觉才能得到结果。

### 2.1.3 深入讨论

下面是一些大致结论

- 在一个好的哈希表中查询时间复杂度是 O(1)
- 在一个平衡性树中查询时间复杂度是 O(log(n))
- 在一个数组中查询的时间复杂度是 O(n)
- 最好的排序算法时间复杂度是 O(n*log(n))
- 差的排序算法时间复杂度是 O(n^2)

时间复杂度有多种类型：

- 平均情况
- 最好情况
- 最差情况

时间复杂度通常选择最差情况。

这里讨论的是时间复杂度，复杂度也可以用在其他地方

- 算法的内存使用情况
- 算法磁盘 I/O 消耗

当然也有很多算法比 n^2 还要糟糕，比如：

- n^4: 这个算法糟糕透了，但是还是有些算法是这个时间复杂度
- 3^n: 这个算法更加糟糕，在这边文章中你将会到这个算法（这个算法用在很多数据库中）
- n!: 即是在小的数据量情况下，你也不能得到结果
- n^n: 如果你得到这个复杂度，你应当问问自己是不是适合 IT 这个行业

注意：在这里我并没有个给出大 O 注记法的真正的定义，你可以从[维基百科]()上查看真正的定义。

## 2.2 归并排序

如果要求排序一个集合，你会怎么做？是的，你可以调用 sort 函数。但是对于一个数据库而言，你需要知道 sort 函数是如何工作的。

有好几种不错的排序算法，但是这里只聚焦于最重要的一个：**归并排序**。现在你可能不清楚为什么数据排序非常有用，但是在查询优化章节后就能明白。而且理解归并排序有助于我们理解数据库中常见的归并连接操作，

### 2.2.1 归并

和其他算法一样，归并排序基于这样的技巧：合并两个已经排序好大小为 N/2 的数组，组成大小为 N 的有序数组，这个过程只需要 N 操作数，这个过程叫做归并。

让我们看看简单的例子：

从上图可知用来从 2 个 4 个元素有序数组构建 8 个元素的有序数组：

- 1)比较当前两个数组当前元素（以第一个元素开始）
- 2)将较小的元素放入 8 个元素数组中
- 3)将较小元素的指针移动到下一个位置
- 重复 1,2,3 步骤直到达到其中一个数组的最后元素
- 将另一个数组的剩余的元素放置在 8 元素数组的最后

主要是因为 4 元素的数组都是有序的，所以就不需要在两个数组进行回溯。

现在我们已经弄清楚这个方法，下面是归并排序的伪代码。

归并排序将问题划分为更小的问题，通过合并更小问题的答案获得原问题的答案（这种算法也叫做分而治之）。这个算法可以划分为两个阶段的算法：

- 划分阶段：将数组划分为更小的数组
- 排序阶段：将两个小数组合并成更大的数组

### 2.2.2 划分阶段

在划分阶段，使用 3 步就将原数组划分为单独元素的数组，步数划分的公式是 log(N) (在这里 N=8，log(N) = 3)。换句话说，每一个都将原数组大小拆分成之前的一半，所需要的步数就是能够除以 2 的次数。

### 2.2.3 排序阶段

在排序阶段，从单个元素开始，在每一步中中使用多个合并，总体需要 N=8 次操作。

- 在第一步中需要 4 次合并，每次需要 2 次操作
- 在第二步中需要 2 次合并，每次需要 4 次操作
- 在第三步中需要 1 次合并，它需要 8 次操作

由于总共有 log(N) 步，所以总体需要 N*log(N) 次操作。

### 2.2.4 归并排序的威力

为什么归并排序算法这么强大呢？主要是因为

- 你可以直接修改它来减少内存使用，换句话说就是不需要创建新的数组而直接修改输入数组。（也就是说这是[原地算法]())
- 你可以修改它来使用磁盘空间外加少量的内存空间而不需要大量的 I/O 操作。将当前所需要处理的部分数据加载到内存中。这一点非常重要尤其是需要排序上 G 的表而只有上百兆内存的时候。（这种算法也叫做[外部排序]()）
- 你可以修改它使之运行在多个处理器/线程/服务器上。比如分布式排序算法就是 [Hadoop]() 最重要的组成部分之一

大部分数据库使用这种排序算法，但是不是唯一的排序算法。如果你对这个感兴趣，可以查看这篇[研究论文]()，它分析了数据库中常见的排序算法的优缺点。

## 2.3 数组、树和哈希表

现在我们已经理解了时间复杂度和排序算法，现在还需要介绍 3 中数据结构，它们非常重要因为它们是数据库后面的基石，最后再介绍数据库索引。

### 2.3.1 数组

二维数组是最简单的数据结构，一张表可以看成一个数组，如下所示

这张 2 维数组就是一张表，它包含行和列：

- 每行代表一个对象
- 每列表示这个对象的一个属性
- 每列存储了特定类型的数据（整数、字符串、日期等等）

尽管这个看上去存储数据不错，但是如果想要查询数据就变得糟糕透了。

比如：如果你想查找某个在 UK 工作的人，你必须要依次查询每一行来判断这一行中该列是否属于 UK。这将要花费 N 操作（ N 是行数），这个虽然看上去不错，那么是否有更快的方法呢？这就是数扮演的作用。

注意：大多数现代数据库提供更先进的数组有效保存表，比如堆组织表或者索引组织表。但是这些并没有改变从特定列中查询问题的效率问题。

### 2.3.2 树和数据库索引

二叉搜索树有特殊的属性，每个节点的键满足如下条件

- 所有键比它小的节点都在左子树
- 所有键比它大的节点都在右子树

让我们直观地看看它的样子

这棵树有 15 个元素，假设我们查找元素 208

- 开始根节点的键为 136， 由于 136 < 208，所以它查看 136 的右子树；
- 398 > 208 所以查看 398 节点的左子树；
- 250 > 208 所以查看 250 节点的左子树；
- 200 < 208 所以查看 200 的右子树，但是 200 节点并没有右子树，也就是说改值不存在。

现在让我们查找元素 40

- 开始以根节点 136 查找，由于 136 > 40, 所以将跳转到 136 的左子树；
- 80 > 40 所以查看 80 的左子树；
- 40 = 40 表明节点存在。从这个节点中获得该行的 ID 值，然后根据该值从上述表中查询；
- 知道行的 ID 能够帮我立即该行确切的值。

最后，整个查询过程消耗时间是这个树的层数，如果你仔细阅读了之前关于归并排序的内容，就会清楚知道公共有 log(N) 层，所以整体查询消耗时间是 log(N).

**回到之前问题**

刚刚讲述的比较抽象所以回到之前我们遇到的问题，现在不是整数了，而是一个字符串代表了之前表格中某人所属的国家，假设你现有有一个数它包含了表格中国家这一列：

- 如果你想知道谁在 UK 工作
- 去那棵树中查询到代表 UK 的节点；
- 在 UK 节点中找到那 UK 工作的行的位置；

整个查询过程消耗 log(N) 操作而不是 N 操作，那么你现在用就是数据库索引。你可以为任何一组列构建树索引（1 个字符串，2 个字符串，1 个整数和 1 个字符串，日期...)，只要你有函数能够比较它们的键，都可以建立一棵有序的键组成的树。

### 2.3.3 B+ 树索引

尽管这棵树在给定值的情况下表现很好，但是如果想要从两个值之间获取多个元素就有一个大问题。它将花费 O(N) 的时间因为你要查看每个节点来检查其值是否在两个之间（比如通过中序遍历树）。还有这些操作不是磁盘 I/O 友好的因为你必须要读取整棵树。我们需要找到一种区间查询的高效方法，为了解决这个问题，现代数据库采用了之前介绍树的一种改进版本 B+ 树，在一棵 B+ 树中：

- 只有最底层的节点（叶节点）存储信息（也就是相应表中行的位置）
- 其他节点仅仅是用来路由到该叶节点的判断条件

正如你看到的，这里有更多的节点（2倍还多），这些额外的节点就是判断节点，它们可以用来帮助找到正确的叶节点。但是查询的时间复杂度仍然是 O(log(N))，仅仅只增加了一层，最大的不同在于最底层的节点连接到它的后继节点。

借助 B+ 树，如果你想要查找位于 40 到 100 之间的值

- 和之前一样查找到 40（如果 40 不存在找最近的值）的节点
- 收集 40 节点所有的后继节点知道该值到达 100

假设你要查找 M 个后继节点而且这棵树有 N 个节点，那么查询特定的节点花费 log(N)，一旦找到该节点，获取 M 个后继节点需要消耗 M 时间复杂度。整个查询仅仅消耗 M+log(N) 操作，和之前 N 操作数有很大的提升。而且你不需要读取整个树（仅仅 M+log(N) 节点），这也就意味着更少的磁盘使用。如果 M 非常小（比如 200 行）N 非常大（100000 行），那么效果会显著不同。

但是这样仍然也存在问题，如果你添加或者删除数据库中的一行（相应的 B+ 树索引也需要修改）：

- 你必须要维持好 B+ 树中内部节点的顺序否则你将无法到达正确的节点位置
- 你必须保持最底层节点的层次，否则时间复杂度将不会是 O(log(N)) 而变成 O(N)

话句话说，B+ 树需要保存自身有序和自身平衡。幸运的是这些删除和插入操作都能正确完成，但是每次插入和删除操作都会花费 O(log(N)) 时间复杂度。这也就为什么你经常听到这样的话：使用过多的索引并不是一个好主意，它将会降低数据库插入、更新和删除操作的效率，因为他们需要更新表相应的索引，对于每个索引都花费 O(log(N)) 时间复杂度，还有增加索引为事务管理器增加的工作负担。

更多细节可以查看维基百科[B+ 树]()。如果想知道数据库中 B+ 树实现的例子，可以查看这篇[文章]()和[这篇文章]()，它们都来自于 MySQL 核心开发人员，他们专注于 innoDB (MySQL 引擎)如何处理索引。

## 2.3.4 哈希表

最后一个重要的数据结构就是哈希表，当你需要快速查询一个值的时候就显得非常重要。还有充分理解哈希表能够帮助我们更好的理解数据库中常见的哈希连接操作，这个数据结构也通常被用作保存数据库内部的东西（比如锁表或者缓冲池，在后果我们都会讨论这些概念）

哈希表可以用来快速地根据一个键找到该元素，但是为了构建一个哈希表你需要定义如下内容：

- 元素的键
- 键的哈希函数，键值计算出来的哈希值用来确定元素的位置（也叫做桶）
- 比较键的函数，一旦找到了需要元素所在的正确桶，需要该函数查找相应键对应的值

**例子**

假设我们有如下可视化的例子

这个哈希表有 10 个桶，为了简便只绘制出 5 个桶。选择的函数是用键对 10 进行取模，换句话说只选择键数值的最后一位来查找桶。

- 如果最后一位数字是 0，那么这个元素在编号为 0 的桶中
- 如果最后一位数字是 1，那么这个元素在编号为 1 的桶中
- 如果最后一位数字是 2，那么这个元素在编号为 2 的桶中

而比较的函数就采用整数的比较方式。

假设你需要查找到 78 的元素

- 78 哈希函数计算出来的哈希值为 8
- 查看桶 8，可以看到第一个元素是 78
- 它返回 78 的元素
- 整个查找过程只消耗了 2 步

现在你需要查找元素 59

- 59 哈希函数计算出来的哈希值为 9
- 查看同 9， 发现第一个元素不是 99，因为 99 != 59, 所以 99 不是一个合适的元素
- 使用同样的逻辑，查看桶元素的第二个元素（9），第三个（79）...以及最后一个元素（29）
- 发现元素不存在
- 整个查找消耗 7 步操作

**好的哈希函数**

正如你所看到的，不同的查询值需要的时间也是不一样的。

在第二个例子中，如果将哈希函数改为对 100000 取模，那么第二种方法只需要一步操作，因为在桶 00059 中没有任何元素，但是带来的挑战是新的哈希函数所需要的桶中只有少量元素。

在这个例子中，找到一个好的哈希函数比较简单，但是如果涉及到下面的情况，找一个好的哈希函数就变得非常困难。

- 字符串
- 两个字符串
- 两个字符串和一个日期

一个好的哈希函数，那么查找的时间复杂度都是 O(1)。

**数组和哈希表比较**

为什么不直接使用数组呢？

- 哈希表可以一部分在内存中，另外一部分在磁盘上
- 使用数组就需要保证连续磁盘空间，当你有一个很大的表时候，这将是非常困难
- 使用哈希表可以使用任何你想要的值作为键

更多细节可以查看我的这篇 [Java HashMap 实现]()文章，这是高效的哈希表实现，你甚至不要知道 Java 语言来理解这篇文章。

# 3 全局概览

刚刚我们已经了解到数据库基础的成分，现在我们需要回过头看看更大的全局概览。

数据库是一个很轻松访问和修改的信息集合，简单的文件就完成同样的工作。事实上，最简单的数据库比如 SQLite 仅仅是一个文件，但是它是一个精心涉及的文件，因为允许你

- 使用事务来保证数据的安全和一致性
- 轻松处理上百万条数据

一般来讲，数据库可以看做如下

在开始写这部分之前，我已经阅读了大量的书籍和论文，每一个参考都有各自的表述方式。所以不要关注我是如何组织数据库或者我们如何命名各个部分，我这样做的原因是为了方便这篇文章，重要的是各个部分的组成部分，需要记住的是数据库可以划分为若干个不同的成分而且每个部分都交互影响。

- 核心组成部分
  - 进程管理：许多数据库有进程/线程池需要管理，为了争分夺秒处理请求，一些现代数据库都是用自己的线程而不是系统线程。
  - 网络管理：网络 I/O 是个大问题，尤其对于分布式数据。这也是为什么数据库需要自己管理网络。
  - 文件管理：磁盘 I/O 是数据库性能的瓶颈，有了文件管理可以有效处理操作系统的文件系统甚至替换它。
  - 内存管理：为了避免磁盘 I/O 就需要大量的内存空间。但是如果处理大量的内存就需要有效地管理，尤其是大量的请求同时需要处理。
  - 安全管理：管理授权和用户授权。
  - 客户端管理：管理客户连接
- 工具
  - 备份管理：保存或者还原数据库。
  - 恢复管理：在崩溃之后能重启数据库。
  - 监控管理：记录数据库的活动以及提供监控数据库的工具。
  - 管理元管理：保存数据库元数据（比如表的名称和结构）和提供管理数据库、表结构和表空间的工具。
- 查询管理
  - 查询解析器：检查查询是否正确
  - 查询重写器：优化查询之前工作
  - 查询优化器：优化查询
  - 查询执行器：编译和执行查询
- 数据管理
  - 事务管理器：处理事务
  - 缓存管理器：在使用之前或者写入磁盘之前，将数据保存在内存中
  - 数据访问管理器：访问磁盘中的数据

文章剩下的部分专注于下面的分布来处理 SQL 查询：

- 客户端管理
- 查询管理
- 数据管理

# 4 客户端管理器

客户端管理器使用处理客户端的通信，它们可以是 Web 服务器或者终端用户/应用程序，它们用很多 API 来访问这些数据库，比如 JDBC，ODBC，OLE-DB...

它们也提供访专门数据库的 API，当你在访问数据库的时候，它将会进行如下操作：

- 管理器首先检查你的权限（登录名和密码），然后检查你是否有权限访问特定的数据库，这些权限都是由数据库管理员设定的
- 然后检查是否有可用的进程（或者线程）来处理请求
- 同样也检查数据库是否在高负载下运行
- 等待片刻就能获取到想要的资源，如果等待超时，就会关闭连接并且返回相应的错误信息
- 将你的查询发送给查询管理器，你的查询将会被处理
- 由于查询并不是一锤子买卖，一旦从查询管理器中获取数据，它将部分数据保存到缓冲区中并开始将数据返回给你
- 中间一旦发生错误，它将关闭连接，返回一个可读的解释原因并且释放相应的资源

# 5 查询管理器

这部分就是数据库魔力所在，一个糟糕的查询可以转变为高效的查询，查询语句就在这里执行并且将结果返回给客户端，这个一个多步骤的集合

- 查询语句首先被解析去检查是否合法
- 重写查询语句来避免无用的操作和增加一些预优化的操作
- 优化查询来提高性能和转化为执行过程和数据访问计划
- 执行计划
- 执行查询

最后两点不做讨论，因为他们相对而言并不重要。

如果你想了解更多，推荐阅读下面材料

- [Access Path Selection in a Releational Databasew Management System]()
- [How DB2.9X optimize the queries]()
- [How PostgreSQL optimize queries]()
- [SQLite Document]()
- [How SQL Server 2006 optimzie queries]()
- [How Oracle 12c optimizition]()
- [Database System concepts]()
- [Join operator, disk I/O]()