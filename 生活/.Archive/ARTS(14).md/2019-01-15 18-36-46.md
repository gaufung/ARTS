---
date: 2019-01-14
status: draft
tags: ARTS
title: ARTS(114)
---

# 1 Algorithm

# 2 Review
[Inverson of Control Container and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html) (Part II)
## 2.7 使用`Service Locator`
使用依赖注入的最大好处是它移除`MoiveLister`类必须要求具体的`MovieFinder`实现，它允许我将这个`lister`给我的朋友们，允许他们在自己的环境中以插件形式完成实现。注入并不是打破依赖的唯一方式，其他的的方法有使用`service locator`。
在`service locator`背后的主要思想是拥有个对象，它知道这个应用程序所需的全部服务，所以这个`service locator`拥有一个方法，它能够将在需要的时候返回一个`movie finder`，当然，它也是仅仅转移的负担，我们仍然需要将`locator`放置在`lister`对象中，导致依赖关系如下：

![](./_image/2019-01-14-18-45-39.png)
在这个例子中，我将使用`ServiceLocator`作为单个的注册器，`Lister`可以在初始化的时候，使用它来获得一个`finder`。
```java
class MovieLister...

  MovieFinder finder = ServiceLocator.movieFinder();
class ServiceLocator...

  public static MovieFinder movieFinder() {
      return soleInstance.movieFinder;
  }
  private static ServiceLocator soleInstance;
  private MovieFinder movieFinder;
```
使用注入的方法，我们需要配置`service locator`，在这里我将用代码进行配置，但是使用读取特定的配置文件的机制也是简单的。
```java
class Tester...

  private void configure() {
      ServiceLocator.load(new ServiceLocator(new ColonMovieFinder("movies1.txt")));
  }
class ServiceLocator...

  public static void load(ServiceLocator arg) {
      soleInstance = arg;
  }

  public ServiceLocator(MovieFinder movieFinder) {
      this.movieFinder = movieFinder;
  }
```
下面是代码
```java
class Tester...

  public void testSimple() {
      configure();
      MovieLister lister = new MovieLister();
      Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
      assertEquals("Once Upon a Time in the West", movies[0].getTitle());
  }
```
我经常听到这样的抱怨，说这类`service locator`是一件不好的事情，因为由于你不能替换实现所以不可测试。当然是你可以设计得很差，导致遇到这个麻烦。在这个例子中，`service locator`实例就是拥有个简单数据，所以我能够创建一个`locator`来测试我的服务。
对于复杂的`locator`, 我可以使用`service ocator`的子类，将这个子类穿点到注册类变量。我可以将这个实例的静态方法来直接访问实例变量。我可以通过线程制定存储来提供一个线程唯一的`locator`。以上所做的都可以完成而不用改变`service locator`的客户端。
其他一种方式认为这个`service locator`是一个注册器而不是一个单例。一个单例仅仅提供简单的方式来实现注册，但是现实的决策非常容易改变。
## 2.8 为`Locator`提供隔离接口
上面的简单的实现方法有个问题就是`MovieLister`依赖整个`service locator`类，尽然它只使用了一个服务。我们可以通过`role interface`来降低它。通过这种方法，`lister`可以声明一些它需要的接口而不是全部。
在这个情况下，`lister`的提供者也将会提供它需要获得`finder`接口全部`locator`中的接口。
```java
public interface MovieFinderLocator {
    public MovieFinder movieFinder();
```
然后这个`locator`需要实现这个接口来提供访问`finder`的接口
```java
MovieFinderLocator locator = ServiceLocator.locator();
MovieFinder finder = locator.movieFinder();
public static ServiceLocator locator() {
     return soleInstance;
 }
 public MovieFinder movieFinder() {
     return movieFinder;
 }
 private static ServiceLocator soleInstance;
 private MovieFinder movieFinder;
```
你将会注意到，由于我们想要使用接口，我们将不能通过静态方法来获得服务。我们需要使用类来获得`locator`实例，然后使用它们来获得我们需要的。
## 2.9 动态的`Service Locator`
上面的例子是静态的，在`service locator`类中用拥有每一个服务需要的`service`，这并不是唯一的方式，我们可以T通过动态`service locator`来允许你隐藏任何你想要的服务。
在这个例子中，`service locator`使用的字典而不是为每个服务提供一个子弹，提供泛型来获取和加载每一个服务。
```java
class ServiceLocator...

  private static ServiceLocator soleInstance;
  public static void load(ServiceLocator arg) {
      soleInstance = arg;
  }
  private Map services = new HashMap();
  public static Object getService(String key){
      return soleInstance.services.get(key);
  }
  public void loadService (String key, Object service) {
      services.put(key, service);
  }
```
配置只需要用正确的`key`来加载服务
```java
class Tester...
  private void configure() {
      ServiceLocator locator = new ServiceLocator();
      locator.loadService("MovieFinder", new ColonMovieFinder("movies1.txt"));
      ServiceLocator.load(locator);
  }
```
使用服务也是用同样的`key`
```java
class MovieLister...
  MovieFinder finder = (MovieFinder) ServiceLocator.getService("MovieFinder");
```
但是从总体来看，我不喜欢这种方法，虽然它看上去很灵活，但是不够清晰具体。我能够找到服务的唯一方法就是通过字符串的`key`。但是我更喜欢使用明确的方法，因为这样更加容易的找到这个接口在哪里定义的。
## 2.10 `Avalon`同时使用了`locator`和注入
依赖注入和`service locator`并不是相互排斥的概念，`Avalon`框架就是很好的同时使用它们的例子。`Avalon`使用`service locator`，但是也使用注入来告诉组件去哪里发现`locator`。
`Berin Lorisch`给我发了一运行`Avalon`的简单例子
```java
public class MyMovieLister implements MovieLister, Serviceable {
    private MovieFinder finder;
 public void service( ServiceManager manager ) throws ServiceException {
        finder = (MovieFinder)manager.lookup("finder");
    } 
```
这个`service`方法就是接口注入的一个方法，允许容器来注入`service`管理器至`MyMovieLister`， 这个`service`管理器是`service locator`的例子。 在这个例子中`lister`并没有在字段中存储`manager`，而是立即使用它来查找这个`finder`，这个的确存储。
## 2.11 如何选择
到目前为止，我们已经重点解释我是如何看待这个模式和它们的变种，现在我可以讨论它们的优缺点来弄清在何时使用它们。
- `service locator` 和 `Dependency Injection`
首先要选择的是在`service locator`和`Dependecy Injection`之间做出选择， 首先一点是它们都提供在基础的例子中的解耦功能，在两个例子中应用程序代码都独立于具体的服务接口实现。这两个模式的不同点在于如何为应用类停工具体的实现。使用`service locator`，应用类使用明确的消息给`locator`，而`injection`并没有显式的请求。因此两者都完成的控制反转。
控制反转就是框架的通用的特色，但是这是由代价的，当你在debug的时候，会发现非常难以理解。所以我一般会避免使用它们除非必须使用它们，并不是说它们是不好的东西，而是我想它需要
# 3 Tips
   - emacs 替换
  `M-x replace-string <RET> string <RET> newstring <RET>`
# 4 Share