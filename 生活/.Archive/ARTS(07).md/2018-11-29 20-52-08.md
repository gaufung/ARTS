---
date: 2018-11-26
status: draft
tags: ARTS
title: ARTS(07)
---

# 1 Algorithm
[八皇后问题](https://en.wikipedia.org/wiki/Eight_queens_puzzle)是一道经典的算法题目，有多种解决问题的思路，甚至知乎上出现出现了[如何使用10行代码完成八皇后](https://www.zhihu.com/question/28543312)问题。
基本的解决问题的思路就是回溯法，不断的尝试每一行的皇后的位置，如果改行无可行的位置的，则回溯上一行皇后的位置。如果上一行皇后的位置也无法放置，则继续回溯，直至第一行。如有甚者，则算法结束。如果到达最后一行，如果位置合法，则表示一个完整的解决方案。
```go
package main

import "fmt"

var solutionCount = 0

// Queue for queue's position
type Queue struct {
	X int
	Y int
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func (q Queue) string() string {
	return fmt.Sprintf("{%d, %d}", q.X, q.Y)
}

func (q Queue) conflict(other Queue) bool {
	if q.X == other.X || q.Y == other.Y || abs(q.X-other.X) == abs(q.Y-other.Y) {
		return true
	} else {
		return false
	}
}

// QueueProblem solving
func QueueProblem(n int) {
	queues := make([]Queue, n, n)
	for idx := range queues {
		queues[idx] = Queue{idx, -1}
	}
	i := 0
	for i >= 0 {
		if i == n {
			printQueues(queues, n)
			i--
		}
		queues[i].Y++
		if queues[i].Y >= n {
			queues[i] = Queue{i, -1}
			i--
		} else {
			if satisfied(queues, i) {
				i++
			}
		}
	}
}

func satisfied(queues []Queue, n int) bool {
	for i := 0; i < n; i++ {
		if queues[i].conflict(queues[n]) {
			return false
		}
	}
	return true
}

func printQueues(queues []Queue, n int) {
	solutionCount++
	fmt.Println("position")
	for i := 0; i < n; i++ {
		fmt.Println(queues[i].string())
	}
}

func main() {
	QueueProblem(8)
	fmt.Printf("solution Count: %d\n", solutionCount)
}
```
# 2 Review
[Return in Go and C#](https://roberto.selbach.ca/returns-in-go-and-c/)
在`Go`语言用户中，大家经常抱怨`Go`的异常处理机制，但是我却认为它是`Go`语言中最有趣的地方。我在这不着重讨论错误处理机制，而且``
# 3 Tips
使用`golang`中的`pprof`工具进行性能分析，首先对于`web`应用程序，添加
```go
import _"net/http/pprof"
```
可以在`localhost:port/debug/pprof`中查看性能分析， 选择`pprof`选线，可以对CPU进行采样分析，经过一段时间，生成`pprof`文件，使用如下命令可以生成`svg`文件
```
go tool pprof ./proff > pprof.svg
```
使用浏览器打开该文件，可以查看每个函数消耗时间。

![](./_image/2018-11-27-22-48-20.jpg)
颜色越深，表明该函数消耗时间越长。
# 4 Share
