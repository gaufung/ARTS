---
title: 关系型数据库是怎么工作的？
status: draft
date:  2019-10-05
---

# 1 前言

当讨论到关系型数据库，我仍不住在想是不是有些东西已经忘了。从短小精悍的 SQLite 到强大的 Teradata，形形色色的关系型数据库广泛被使用，但是很少有文章去解释它们是如何工作的。你可以在 google 搜索框内输入 ”关系型数据库是如何工作的“ 来查看相应的结果，但是更多情况下都是都是非常短文章。现在如果你查看最新流行的技术（大数据，NoSQL 或者 JavaScript)，你会找到很多深入的文章来解释它们是如何工作的。

是不是关系型数据库它老旧了或者太无聊了，以至于除了大学教程、研究论文或者书籍之外都不愿意在讨论它了？

作为一个开发者，我**讨厌**使用我不理解的东西，而作为已经诞生 40 余年的关系型数据库，其中一定包含大量的奥秘。过去几年我花费了上百个小时来搞清楚这个每天使用的黑盒子的原理。关系型数据库非常有趣因为它建立在一些有用并且可重用的概念之上，如果你对理解数据库感兴趣但是没有时间或者意愿花大量的时间在这个主题上，你一定会喜欢这边文章。

尽管标题非常清晰，但是还是要强调这篇文章的目的并不是掌握如何使用数据库，因此你应当知道如何写一些简单的查询或者基本的 CRUD 操作，否则你将不会理解这篇文章。你只需要里了解这些，剩下的我都会一一解释。

我将以计算机科学中的时间复杂度概念展开，我知道你们其中可能会讨厌这个概念，但是没有它就不能理解数据库中的精妙之处。因为这是一个宏大的主题，我将专注于我认为比较重要的内容：数据库是如何处理 SQL 查询，在阅读完文章后可以查阅更多的相关的内容。

这篇文章非常长并且涉及了很多算法和数据结构，请保持耐心阅读。如果有些概念目前很难理解，可以尝试跳过它们，这并不妨碍你获得一个全局的印象。整个文章可以分为三个部分：

- 低层次和高层次数据库组成部分的概览
- 查询优化过程的概览
- 事务和缓冲池的概览

# 2 基础知识

无论什么时候，开发者都必须要知道他的代码会执行多少次操作，而且必须彻底的掌握使用的算法和数据结构，因为浪费 CPU 操作和内存是一件不可接受的事。在本小节中我会提及这些概念因为对理解数据库是非常重要的，尤其是在介绍数据库索引的概念的时候。

## 2.1 O(1) 和 O(n^2)

如今很多开发者并不关心时间复杂度，从某种意义上它们是正确的。但是当你处理大量数据或者为优化毫秒操作的时候，时间复杂度就变得非常重要了。对于数据库而言，这两种情况都是需要重点考虑的，尤其在理解基于成本数据库查询优化概念的时候非常重要。

### 2.1.1 概念

时间复杂度概念用来描述一个算法在给定的数据量情况下所花费的时间。为了描述这个复杂度，计算机科学家使用了数学概念中大 O 注记法，该方法使用函数来描述一个算法在给定数据量情况下该算法的操作数。举例来讲当我们说
> 这个算法是 O(some_function())

也就是说在给定数据量的输入条件下，需要 some_function(数据量) 的操作来完成任务。

重要的不是数据量大小，而是当数据量增加时需要操作数增加的方式。时间复杂度并不会给出确切的操作数而且大致的示意。

从上图中可以看到不同类型的时间复杂度演变，在这里我使用对数量级来绘制这张图，也就是说，数据量迅速从 1 增加到 10 亿，从中我们可以看到：

- O(1) 或者常数复杂度始终保持常数（否则就不会叫做常数复杂度）
- O(log(n)) 复杂度在 10 亿数量级还是保持很低
- 最差的时间复杂度是 O(n^2)，因为它操作数呈现爆炸式增长
- 剩余的时间复杂度的操作数也是迅速增加

### 2.1.2 示例

在低数量级别的时候，O(1) 和 O(n^2) 的差距是不明显，比如说假设你有一个算法处理 2000 元素：

- O(1) 算法需要花费 1 次操作
- O(log(n)) 算法需要花费 7 次操作
- O(n) 算法需要花费 2000 次操作
- O(n*log(n)) 算法需要花费 14000 次操作
- O(n^2) 算法需要花费 4000000 次操作

O(1) 和 O(n^2) 算法的区别看上去有点大（4 百万），但是实际上最多消耗 2 毫秒，也就是一眨眼的功夫，因为目前的处理器大概在每秒钟能够处理百万次操作，这也就是为什么在很多 IT 项目中性能和优化并不是问题。

但是正如说过，如果处理大量数据的时候就非常重要了。这一次算法需要处理 100000 个元素（对于数据库而言并不算是很大）。

- O(1) 算法需要花费 1 次操作
- O(log(n)) 算法需要花费 14 次操作
- O(n) 算法需要花费 1000000 次操作
- O(n*log(n)) 算法需要花费 14000000 次操作
- O(n^2) 算法需要花费 1000000000000 次操作

这一次没有做数学计算但是我可以说 O(n^2) 算法的操作时间可以去煮一杯咖啡了。如果你在输入数据后面增加一个 0，你可以去睡一觉才能得到结果。

### 2.1.3 深入讨论

下面是一些大致结论

- 在一个好的哈希表中查询时间复杂度是 O(1)
- 在一个平衡性树中查询时间复杂度是 O(log(n))
- 在一个数组中查询的时间复杂度是 O(n)
- 最好的排序算法时间复杂度是 O(n*log(n))
- 差的排序算法时间复杂度是 O(n^2)

时间复杂度有多种类型：

- 平均情况
- 最好情况
- 最差情况

时间复杂度通常选择最差情况。

这里讨论的是时间复杂度，复杂度也可以用在其他地方

- 算法的内存使用情况
- 算法磁盘 I/O 消耗

当然也有很多算法比 n^2 还要糟糕，比如：

- n^4: 这个算法糟糕透了，但是还是有些算法是这个时间复杂度
- 3^n: 这个算法更加糟糕，在这边文章中你将会到这个算法（这个算法用在很多数据库中）
- n!: 即是在小的数据量情况下，你也不能得到结果
- n^n: 如果你得到这个复杂度，你应当问问自己是不是适合 IT 这个行业

注意：在这里我并没有个给出大 O 注记法的真正的定义，你可以从[维基百科]()上查看真正的定义。

