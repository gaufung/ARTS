---
date: 2019-07-15
status: public
tags: APUE
title: APUE(09)
---

# 1 终端登录
文件 `/etc/ttys` 中每一行代表了终端设备，内核创建的 `init` 进程使系统进入多用户模式，对每一允许登录的终端设备调用 `fork`，生成的子进程值执行 `exec getty` 程序。
`getty` 对终端设备调用 `open` 函数，读写的方式打开，用类似下面的方式输出登录信息
```c
execle("/bin/login", "login", "-p", username, (char *)0, envp);
```
调用形式如下：
![](./_image/2019-07-15-20-53-24.jpg?r=50)
上图中所有的进程都是超级用户权限，所有的父进程都是 1。在完成登录后，`login` 将要完成以下事情
- 将当期工作目录调整为用户起始目录；
- 调用 `chown` 更改终端所有权；
- 将对终端设备的访问权限设置为用户读和写
- 调用 `setgid` 和 `initgroups` 设置进程组ID
- 用 `login` 得到的所有信息初始化环境
- `login` 进程更改登录用户 ID 并调用相应的 `shell`

# 2 进程组
每个进程除了有一个进程 ID 之外，还属于一个进程组，一个进程组通常包含多个进程，是在同一个作业中结合起来。同一进程组中的集合接受来自同一终端的各种信号。
```c
# include <unistd.h>
pid_t getpgrp(void);
```
每个进程组有一个组长进程，组长进程的进程组 ID 等于其进程 ID。调用 `setpgid` 可以加入一个现有的进程组或者创建一个新的进程组。
```c
# include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
```

- 如果两个参数相等，则 `pid` 指定的进程变成进程组组长。
- 如果 `pid` 等于 0， 则使用调用者的进程 ID。
- 如果 `pgid` 等于 0， 则是指定的进程 ID 为进程组 ID。

# 3 会话
是由一个或者多个进程组的集合。

![](./_image/2019-07-16-06-33-58.jpg?r=57)
上面的会话可能是这样形成的
```shell
proc1 | proc2 &
proc3 | proc4 | proc5
```

进程调用 `setsid` 可以创建一个新的会话
```c
# include <unistd.h>
pid_t setsid(void);
```
1. 该进程会变成新会话的首进程，该进程是新会话的唯一进程；
2. 该进程成为新进程组的组长进程；
3. 该进程没有控制终端；

# 4 控制终端
会话和进程组有一下特性
1. 一个会话可以有一个控制终端，通常是终端设备；
2. 建立与控制终端连接的会话首进程称为控制进程；
3. 一个会话中的几个进程组可分为一个前台进程组和一个或者多个后台进程组。
4. 如果一个会话只有一个控制终端，则一个前台进程组，其余的进程组都是后台进程组。
5. 如论何时键入终端中断键（`Delete` 或者 `Ctrl+C`)，都会将中断信号发送至前台进程组的所欲进程；
6. 无论何时键入退出键(`Ctrl+\`)，都会将退出信号发送至前台进程组的所有进程
7. 如果终端接口检测到已经断开连接，则将挂断信号发送至会话首进程。