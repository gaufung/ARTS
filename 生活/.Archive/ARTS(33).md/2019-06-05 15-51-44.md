---
date: 2019-06-03
status: public
tags: ARTS
title: ARTS(33)
---

# 1 Algorithm 
> 输入一个字符串，包含了 `+`, `-`, `*`, `/` 和非负整数，请输出该计算表达式的值。
> 例如： `1 + 12 - 4 * 2`，输出的结果就是 `5`。

算法要求我们编写一个类似计算器的函数，输入为表达式计算，输出为表达式的值。如果写过编译器，这个问题不难，只要构建出一个抽象语法树（`AST, Abstract Syntax Tree`) 即可。
![](./_image/2019-06-04-16-55-42.jpg?r=51)
写个编译器有点小题大做，可以借助栈结构完成同样的目的。创建两个栈，分别存放操作数(` operand `)和操作符(` operator `)，当待入栈的操作符优先级比栈顶操作符优先级小，则将栈顶操作符出栈，并且从操作数栈出栈相应的操作数并进行计算，将计算结果重新入栈，如此迭代直到操作符为空，操作符栈顶元素就是表达式最终结果。
![](./_image/calc.png)
```go
func calculator(s string) int {
	operandStack := NewStack()
	operatorStack := NewStack()
	lexer := NewLexer(s)
	operations := map[string]func(int, int) int{
		"+": func(a, b int) int { return a + b },
		"-": func(a, b int) int { return a - b },
		"*": func(a, b int) int { return a * b },
		"/": func(a, b int) int { return a / b },
	}
	precedences := map[string]map[string]bool{
		"+": {"+": false, "-": false, "*": false, "/": false},
		"-": {"+": false, "-": false, "*": false, "/": false},
		"*": {"+": true, "-": true, "*": false, "/": false},
		"/": {"+": true, "-": true, "*": false, "/": false},
	}
	for {
		token, literal := lexer.Next()
		if token == EOF {
			break
		}
		if token == NUMBER {
			number, _ := strconv.Atoi(literal)
			operandStack.Push(number)
		} else {
			for {
				if operatorStack.Empty() {
					operatorStack.Push(literal)
					break
				} else {
					top := operatorStack.Top().(string)
					if precedences[literal][top] == false {
						operand2 := operandStack.Pop().(int)
						operand1 := operandStack.Pop().(int)
						result := operations[top](operand1, operand2)
						operatorStack.Pop()
						operandStack.Push(result)
					} else {
						operatorStack.Push(literal)
						break
					}
				}
			}

		}
	}
	for !operatorStack.Empty() {
		operator := operatorStack.Pop().(string)
		operand2 := operandStack.Pop().(int)
		operand1 := operandStack.Pop().(int)
		result := operations[operator](operand1, operand2)
		operandStack.Push(result)
	}
	return operandStack.Top().(int)
}

type Token int

const (
	NUMBER Token = iota
	OPERATOR
	EOF
)

type Lexer struct {
	input   []byte
	pos     int
	readPos int
}

func NewLexer(expression string) *Lexer {
	return &Lexer{
		input:   []byte(expression),
		pos:     0,
		readPos: 0,
	}
}

func (l *Lexer) Next() (Token, string) {
	l.skipWhiteSpace()
	if l.pos == len(l.input) {
		return EOF, ""
	}
	if l.input[l.pos] == '+' || l.input[l.pos] == '-' || l.input[l.pos] == '*' || l.input[l.pos] == '/' {
		literal := string(l.input[l.pos : l.pos+1])
		l.pos++
		return OPERATOR, literal
	} else {
		return NUMBER, l.readNumber()
	}
}

func (l *Lexer) skipWhiteSpace() {
	for l.pos < len(l.input) && l.input[l.pos] == ' ' {
		l.pos++
	}
}

func (l *Lexer) readNumber() string {
	l.readPos = l.pos + 1
	for l.readPos < len(l.input) && isDigits(l.input[l.readPos]) {
		l.readPos++
	}
	literal := string(l.input[l.pos:l.readPos])
	l.pos = l.readPos
	return literal
}

func isDigits(ch byte) bool {
	return ch >= '0' && ch <= '9'
}

type Stack struct {
	elements []interface{}
	size     int
}

func NewStack() *Stack {
	return &Stack{
		elements: make([]interface{}, 0),
		size:     0,
	}
}

func (s *Stack) Push(v interface{}) {
	s.elements = append(s.elements, v)
	s.size++
}

func (s *Stack) Pop() interface{} {
	s.size--
	val := s.elements[s.size]
	s.elements = s.elements[:s.size]
	return val
}
func (s *Stack) Top() interface{} {
	return s.elements[s.size-1]
}

func (s *Stack) Empty() bool {
	return s.size == 0
}
```
辅助类 `Lexer` 用来解析输入字符串的 `Token`，对输入的字符串解析出操作符( `Operator` ) 和操作数( `Operand` )，分别放入相应的栈中。而 `precedences` 查询表判断当前待入栈的操作符与栈顶操作符的比较，如果为 `true`，则入栈，否则将栈顶操作符出栈并计算。在解析后全部的 `Token` 后，如果操作符栈不为空，仍然要依次退栈，计算出全部的结果，直到为空。
# 2 Review
[What happens when you type 'google.com' into a browser and press Enter?](https://dev.to/antonfrattaroli/what-happens-when-you-type-googlecom-into-a-browser-and-press-enter-39g8?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

**在浏览器中输入`google.com` 之后按下回车键，接下来会发生什么？**

至今我遇到的最喜欢的面试题目是：
> 当你在浏览器中输入 `google.com` 地址后，然后按下 `<Enter>` 键，接下来会发生什么？

有些人为了整个完整性，可以在这个问题上回答一整天。那么他们究竟讨论得有多深？在这篇文章中，我将会讨论这些，当我在现实面试中遇到这个提问，在面试官打断我之前，我足足讲了十几分钟。在面试结束后，我将在面试中没有包含的内容重新整理了一下。

*究竟发生了什么？*
浏览器首先分析输入，通常如果输入内容包含 `.com`，那么它不会认为这是搜索的内容。一旦它认为这是 `URL`，它就会检查它的 `scheme`，如果没有就在开头添加 `http://` 协议，由于你没有指定特定的 `HTTP` 协议就假定默认值，比如端口号选定 `80`, `GET` 方法和无验证授权等。
然后它就创建一个 `HTTP` 请求发送出去，对底层的网络知识还不是很自信但是如果要将的话就包含 `MAC` 地址，`TCP` 包传递，丢包处理等等。无论如何，都会进行 `google.com` DNS 查询操作。如果 `DNS` 服务并没有缓存这个域名，它将返回一系列 `IP` 地址，因为 `google.com` 并不是只有一个 `IP` 地址。我想浏览器会默认选择第一个地址，但是不是很清楚 `IP` 地址地域分布或者 `IP` 地址列表是如何收集的。
接下来 `HTTP` 请求从不同节点之间跳转直到 `google.com` IP 地址的负载均衡器。但是这个不会持续很长时间，`Google` 服务器会给出响应要求浏览器使用 `HTTPS` 协议，这个通过 `301` 响应码跳转。沿着原路返回到浏览器，浏览器改用 `HTTPS` 协议和默认 `443` 端口重新发送请求。这时候在浏览器和负载均衡器之间进行 `TLS` 握手。请求会告诉 `Google` 服务器它可以支持哪些 `TLS` 协议（`TLS 1.0 1.1 1.2`)，`Google` 服务器会响应具体的协议版本，之后请求就会使用 `TLS` 进行加密。
接下来是 `Google` 服务器将请求通过负载均衡器上的防火墙来判断这个是否为恶意请求，一旦通过防火墙验证，安全连接就会

# 3 Tips

# 4 Share