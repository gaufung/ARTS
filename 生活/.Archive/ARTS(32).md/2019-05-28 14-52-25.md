---
date: 2019-05-27
status: public
tags: ARTS
title: ARTS(32)
---

# 1 Algorithm
> 给定一个数组，有两个元素只出现了一次，而其余的出现了两次，找出两个只出现一次的元素，要求时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

对于位运算异或(`^`)，有如下性质

- `a ^ a = 0`
- `0 ^ a = a`
- `a ^ b ^ c = a ^ (b ^ c)`

如果数组中的元素都出现两次，那么对其所有元素进行异或操作最终结果必然为 `0`，如果元素中只有一个元素只出现了一次，那么所有元素异或的结果就是只出现一次的元素。那么两个元素只出现一次，那么该如何解决呢？
通过上述性质我们可以得知，最终的异或结果肯定不等于 `0`，也就是说肯定至少一位 `bit` 为 `1`，而且只出现一次的两个元素在该比特位数值不相同。所以通过这一个比特位将数组元素划分为两组，只出现一次的元素元素分别划分到这个两组中。按照上一步解决问题的方法，就可以找出只出现一次的元素。

```go
func onlyOnce(nums []int) []int{
    res := 0
    for _, num := range nums {
        res ^= num
    }
    i:=0
    for {
       if res & (mask <<i)  == (mask << i){
           break
       }
       i++
    }
    res1, res2 := 0, 0
    for _, num := range nums {
       if num & (mask << i) == (mask <<i) {
           res1 ^= num
       }else{
           res2 ^= num
       }
    }
    return []int{res1, res2}
}
```

# 2 Review

[Life of Binary](https://kishuagarwal.github.io/life-of-a-binary.html)

**二进制文件的前世今生**

## 2.1 概览
几乎你们中所有人都编写过程序，编码、编译和运行一气呵成，接下来就可以享受代码运行的成果。但是除此之外，你还需要感谢你的编译器在背后默默所做的工作（当然前提假设你在使用编译语言，而不是解释型语言）。
在本篇文章中，我将尝试想你展示你编写源代码如何转换成你的机器能够运行的文件。我选择 Linux 作为我的宿主机和 C 语言作为代码示例，这里涉及到的概念可以很方便的推广至其他编译型语言。
**注意：** 如果你一步步试着这篇文章的内容，你需要确保在你本地机器上已经安装好 `gcc` 和 `elfutils` 两个工具。
接下来以一个简单的 C 语言程序为例，然后观察它是如何被编译器一步步转换的。

```c:n
#include <stdio.h>

// Main function
int main(void){
    int a = 1;
    int b = 2;
    int c = a + b;
    printf("%d\n", c);
    return 0;
}
```

这个程序创建两个变量，将它们加起来然后在屏幕上将结果打印出来。是不是很简单？但是我们可以通过这个简单的程序来了解到程序最终是如何在机器上执行的。
编译器一般有一下五个步骤：
![](./_image/2019-05-27-17-29-00.jpg)
让我们一步步了解这写步骤并且探索更加详细的细节。

## 2.2 预处理
![](./_image/2019-05-28-09-01-48.jpg)
预处理阶段是由预处理器完成的，预处理器所做的工作就是来处理所有代码中所有预处理标识。这些标识符是有个 `#` 开头，但是在处理它们之前，它首先移除代码中所有的注释，因为它们仅仅是给人来阅读的。然后它寻找所有的 `#` 命令，并且执行这些命令。
在上述代码中，我们只使用了 `#include` 标识符，它就是告诉预处理器将 `stdio.h` 文件的拷贝至挡墙当前文件所在的位置。
你可以通过给 `gcc` 传递 `-E` 标识就可以看到预处理器的输出。
```shell
gcc -E sample.c
```
你将会看到如下的输出
```c:n
# 1 "sample.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "sample.c"

# 1 "/usr/include/stdio.h" 1 3 4

-----omitted-----


# 5 "sample.c"
int main(void) {
    int a = 1;
    int b = 2;
    int c = a + b;
    printf("%d\n", c);
    return 0;
}
```

## 2.3 编译
![](./_image/2019-05-28-09-02-17.jpg)
令人不解的是第二步也叫做编译，编译器从预处理的输出做如下的重要的工作。
- 将输出内容传递给词法分析器来判定文件中不同的 `token`。`token` 是用来表示你程序中诸如 `int`, `return`, `void`, `0` 等等。词法分析器也将每一个 `token` 同它所属的类型关联起来，无论它是字面字符串、整型、浮点型等等。
- 将词法分析器的输出传递给语法分析器来检查编写的程序是否满足编程语言的语法规则。比如下面的一行代码将会引发语法错误
```c
b = a + ;
```
因为这里的 `+` 缺失一个操作数。
- 将语法分析器的输出传递个语义分析器，它来检查程序是否满足类型检查、使用前声明变量等规则。
- 如果程序语法正确，那么程序源码将会转换为目标机器架构的汇编指令。默认它会以当前运行机器为目标机器。当然，如果你要为嵌入式系统构建程序，你可以将目标机器的架构传递给构建命令，`gcc` 可以为该机器生成汇编指令。

为了得到这一步的输出，传递 `-S` 标识至 `gcc` 编译器。
```
gcc -S sample.c
```
你将会得到如下结果，当然这个取决于你的环境。
```asm:n
    .file   "sample.c"                              // name of the source file
    .section    .rodata                             // Read only data
.LC0:                                               // Local constant
    .string "%d\n"                                  // string constant we used
    .text                                           // beginning of the code segment
    .globl  main                                    // declare main symbol to be global
    .type   main, @function                         // main is a function
main:                                               // beginning of main function
.LFB0:                                              // Local function beginning
    .cfi_startproc                                  // ignore them
    pushq   %rbp                                    // save the caller's frame pointer
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp                              // set the current stack pointer as the frame base pointer
    .cfi_def_cfa_register 6
    subq    $16, %rsp                               // set up the space
    movl    $1, -12(%rbp)
    movl    $2, -8(%rbp)
    movl    -12(%rbp), %edx
    movl    -8(%rbp), %eax
    addl    %edx, %eax
    movl    %eax, -4(%rbp)
    movl    -4(%rbp), %eax
    movl    %eax, %esi
    movl    $.LC0, %edi
    movl    $0, %eax
    call    printf
    movl    $0, %eax
    leave
    .cfi_def_cfa 7, 8
    ret                                             // return from the function
    .cfi_endproc
.LFE0:
    .size   main, .-main                            // size of the main function
    .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"
    .section    .note.GNU-stack,"",@progbits        // make stack non-executable
```
如果你之前没有接触过汇编语言，这个看上去很吓人，但是也没有那么恐怖。相比较于常见的高级语言，理解汇编代码需要花更多的时间，如果给定时间充分，你肯定能够读懂它。
让我们来看看这个文件包含了什么。
所有以 `.` 开头行都是汇编命令。`.file` 说明源文件名称，它用来进行 debug 操作。源码中的 `%d\n` 字面字符串被保存在 `.rodata` 节中（`ro` 意味着只读），因为它只读字符串。编译器将这个字符串命名为 `LC0`，在后面的代码可以引用这个。无论什么时候遇到以 `.L` 开头的标记，它都表明这些标识都是当前文件的本地，在其他文件中是不可见的。
`.global` 告诉我们 `main` 是全局符号，这也就意味着 `main` 函数可以从其他文件中调用。`.type` 告诉我们 `main` 是一个函数。接下来 `main` 函数的汇编代码。你可以忽视所有以 `cfi` 开头的指令，它们是用来在异常发生的时候进行栈展开时候用的。在本篇文章中我将会忽略这些，但是如果你要了解更多，可以参考如下[链接](https://sourceware.org/binutils/docs/as/CFI-directives.html)
现在让我们充分理解 `main` 函数的汇编。

![](./_image/2019-05-27-19-10-54.jpg)
`11.` 你应当知道当你在调用函数的时候，必须要为这个函数调用创建一个栈帧。为了实现它，在新的函数返回时候，我们需要知道调用函数栈帧所指的位置。这也就是为什么我么需要将当前栈帧指针，也就是保存在 `rbp` 寄存器中的值压入栈中。
`14` 将当前栈指针移动到基指针，它变成了当前函数的栈指针。上图（1）示意当将 `rbp` 寄存器入栈之前的转态；图（2）展示了之前栈帧入栈后栈帧指针移动到当前函数栈帧指针的情况。
`16` 我们程序中包含了 3 个局部变量，它们类型都是整型。在我的机器中，每个 int 型占用 4 个字节，所以我们需要在栈上分配 12 个字节来保存局部变量。在这里我们通过为本地变量在栈上分配只需要将栈指针减少到需要的字节数。使用减的原因是栈增长的方向是从高地址向低地址生长。但是你可以看到我们在这里减少了 16 而不是 12，这里的原因是空间分配的单位就是 16 字节。所以即使你需要一个局部变量，也有 16 字节空间在栈上分配，这样做的原因是在一些架构上有更好的性能表现。图（3） 展示了现在栈空间分布情况。
`17-22` 这部分代码非常直接，编译器使用 `rbp-12` 槽位作为变量 a 存储空间，`rbp-8` 作为 b 存储空间， 同样地使用 `rbp-4` 为 c 保留空间。然后分别将值 1 和值 2 放到 a 和 b 的地址。为了准备加法，它将 b 值移动到 `edx` 寄存器，然后将 a 值移动 `eax` 寄存器。加法的结果值保存到 `eax` 寄存器，最后将结果保存到变量 c 的地址。
`23-27` 然后我们准备 `printf` 调用，首先将 c 变量的值移动到 `esi` 寄存器中，然后将字符串常量 `%d\n` 的地址移动到 `edi` 寄存器。现在 `esi` 和 `edi` 寄存器保存 `printf` 函数调用的参数， `edi` 保存到第一个参数，`esi` 保存第二个参数。然后我们调动 `printf` 函数来将变量 c 格式化格式化成整型。特别要注意的是在这里 `printf` 符号还没有定义，接下来我们会看到如何解析 `printf` 符号。
`.size` 说明了 `main` 函数字节大小；`.-main` 是一个表达式，而 `.` 符号表示当前行的地址。所以当前的表示是是计算 `当前行的地址` - `main 函数地址`，结果就是 `main` 函数的字节大小。
`.dent` 告诉汇编器将下面行添加到 `.comment` 节。`.note.GNU-stack` 用来表明当前栈是否可执行，大部分情况下这是空字符串，这表明这个栈是不能执行的。

## 2.4 汇编
![](./_image/2019-05-28-09-01-19.jpg)
现在我们的程序已经是汇编语言了，但是处理器还是不能理解它们，我们需要将汇编代码转换成机器代码，而这些工作是由汇编器完成的。汇编器输入你的汇编文件然后生成目标文件，目标文件包含了你程序中的机器指令。
现在我们开始进行这一步操作，为了得到目标文件，需要将 `c` 标记传递个 `gcc` 编译器。
```shell
gcc -c sample.c
```
你将会得到的以 `o` 为拓展名的目标文件，这一次我们无法通过普通的文本编辑器来打开它们。但是我们可以借助工具来查看究竟里面包含哪些内容。
目标文件有很多不同的文件格式，在这里我们专注特定的一种，也就是 Linux 平台使用的 [`ELF`](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 文件格式。
`ELF` 文件包含一下信息：
-  `ELF` 文件头
- 程序头表
- 节头表
- 引用前面表的其他数据

`ELF` 文件头包含目标文件的元信息，比如文件类型、编译机器类型、版本号、文件头大小等等。为了查看文件头，我们需要为 `eu-readelf` 工具传递 `-h` 标识。
```shell:n
$ eu-readelf -h sample.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Ident Version:                     1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           AMD x86-64
  Version:                           1 (current)
  Entry point address:               0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          704 (bytes into file)
  Flags:                             
  Size of this header:               64 (bytes)
  Size of program header entries:    0 (bytes)
  Number of program headers entries: 0
  Size of section header entries:    64 (bytes)
  Number of section headers entries: 13
  Section header string table index: 10
```
从上面列出来的，我们可以知道我们文件不包含任何程序头表，也是符合预期的，因为程序头表只存在可执行文件和共享文件中。在下面的链接步骤，我们就可以看到程序头表。
在这里我们包含 13 个节，为了查看这些节，我们传递 `-S` 标识。
```shell:n
$ eu-readelf -S sample.o
There are 13 section headers, starting at offset 0x2c0:

Section Headers:
[Nr] Name                 Type         Addr             Off      Size     ES Flags Lk Inf Al
[ 0]                      NULL         0000000000000000 00000000 00000000  0        0   0  0
[ 1] .text                PROGBITS     0000000000000000 00000040 0000003c  0 AX     0   0  1
[ 2] .rela.text           RELA         0000000000000000 00000210 00000030 24 I     11   1  8
[ 3] .data                PROGBITS     0000000000000000 0000007c 00000000  0 WA     0   0  1
[ 4] .bss                 NOBITS       0000000000000000 0000007c 00000000  0 WA     0   0  1
[ 5] .rodata              PROGBITS     0000000000000000 0000007c 00000004  0 A      0   0  1
[ 6] .comment             PROGBITS     0000000000000000 00000080 00000035  1 MS     0   0  1
[ 7] .note.GNU-stack      PROGBITS     0000000000000000 000000b5 00000000  0        0   0  1
[ 8] .eh_frame            PROGBITS     0000000000000000 000000b8 00000038  0 A      0   0  8
[ 9] .rela.eh_frame       RELA         0000000000000000 00000240 00000018 24 I     11   8  8
[10] .shstrtab            STRTAB       0000000000000000 00000258 00000061  0        0   0  1
[11] .symtab              SYMTAB       0000000000000000 000000f0 00000108 24       12   9  8
[12] .strtab              STRTAB       0000000000000000 000001f8 00000016  0        0   0  1
```
你不必知道上述所有的节内容，每一个节都包含了很多信息，比如名称、大小和偏移量。下面是重要的节的介绍：
- `text` 节包含了机器代码；
- `rodata` 节包含了我们程序中包含只读数据，比如程序中常量和字面字符串，在这里它只包含 `%d\n` 字符串；
- `data` 节包含程序中已经初始化的数据，在这里是空的因为程序中不包含已经初始化的数据；
- `bss` 节和 `data` 节差不多但是它是包含程序中未初始化的数据。未初始化的数据比如 `int arr[100]` 的声明，它就包含在 `bss` 节中。有一点需要注意的是 `bss` 节和其他节不同，它只包含该节占用大小而没有其他内容任何东西。这样做的原因是在加载的时候，这些所需要分配空间的数据都会在这一节分配，这样就能减小执行文件的大小；
- `strtab` 节包含程序所需要的全部字符串；
- `symtab` 节属于符号表，它包含程序中所有的符号；
- `rela.text` 节是重定位节，接下来我们会看到它。

你可以传递节的编号至 `en-readelf` 工具就可以查看该节的内容，同样也可以是使用 `objdump` 工具，因为它能提供查看一些节的内容。
让我们讨论一下 `rela.text` 节更加详细的内容，
# 3 Tip

# 4 Share