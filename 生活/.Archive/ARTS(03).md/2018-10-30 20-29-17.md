---
date: 2018-10-28
status: public
tags: ARTS
title: ARTS(03)
---
# 1  Algorithm
换硬币问题(`currency exchange`)

# 2 Review
## 2.1 [What Programmer Can Do](https://lwn.net/Articles/255364/)
### 2.1.1 L1缓存
我们知道对于多维数组，数据存储是按照一定的循序的，将多维的数据按照一维的内存数组存储，对于一个二维数组，存储的形式如下：
![](./_image/2018-10-30-18-46-15.jpg)
如果访问内存的采用不同的索引顺序，第一种采用行索引优先；另一种采用列索引有限的方式，各自的时间消耗分别为：`0.048s`和`0.127s`，采用行索引优先的方式充分使用了缓存的空间局部性，使缓存行能够保存一行数组。如果数组的大小很大，时间消耗对比将更加突出。
对于矩阵 $A$ 和 $B$  相乘，算法过程大致如下:
```C
for(i = 0; i < N; ++i)
    for(j = 0; j < N; ++j)
        for(k =0; k < N; ++k)
            res[i][j] += mul1[i][k] * mul2[k][j];
```
通过刚刚知道，对于矩阵`mul1`充分使用缓存，但是对于矩阵`mul2`并没有使用缓存；因此需要一种更好的方式访问`mul2`元素：可以使用转置矩阵`mul2`:
$$
(AB)_{ij}=\Sigma_{k=0}^{N-1}a_{ik}b_{jk}^T = a_{i1}b_{j1}^T+a_{i2}b_{j2}^T + \ldots + a_{i(N-1)}b_{j(N-1)}^T
$$
算法过程如下
```C
double tmp[N][N];
for(i =0; i<N; ++i)
    for (j =0; j<N; ++j)
        tmp[i][j] = mul2[j][i]
for(i = 0; i < N; ++i)
    for(j = 0; j < N; ++j)
        for(k =0; k < N; ++k)
            res[i][j] += mul1[i][k] * tmp[j][k];
```
算法的效果是显著地，对比结果如下：
![](./_image/2018-10-30-19-04-21.jpg)
重新拷贝数组仍然不够完美，如果矩阵特别大，将会导致巨大的内存浪费。仔细观察矩阵相乘的数学表达式，可以得到相乘然后相加顺序不影响最后的结果，因此重新调整相加的顺序，使得每个相乘的数据都是在缓存行中。将$A$和$B$矩阵划分若干矩阵块，并且每个矩阵块的行大小为缓存行大小：
![](./_image/2018-10-30-20-20-17.jpg)
在每个子矩阵中， $A_{i*}$和$B_{*j}$都保存在缓存行中，然后用$A_{i*}$中的元素依次乘上$B_{*.j}$一行元素。作为结果$res_{ij}$的一部分。算法流程如下：
```C
#define SM (CLS / sizeof (double))
for (i = 0; i < N; i+=SM)
    for(j=0; j<N; j+=SM)
        for(k=0; k<N; k+= SM)
            for(i2=0, rres = &res[i][j], rmul1 = &mul1[i][k]; i2<SM)
```
## 2.2 
# 3 Tips
# 4 Share