---
date: 2018-12-10
status: public
tags: CSAPP
title: 链接器是如何工作
---
# 1 编译程序
对于如下简单的C程序：
```c
// main.c
int sum(int *a, int n);
int array[2] = {1, 2};
int main()
{
    int val = sum(array, 2);
    return val
}
// sum.c
int sum(int *a, int n)
{
    int i, s = 0;
    for (i =0; i < n; i++){
        s += a[i]
    }
    return s;
}
```
使用`gcc`来编译成可执行程序：
```shell
gcc -Og -o prog main.c sum.c
```
那么完整的中间流程如下:
- C预处理器，将源程序`main.c`翻译成ASCII码中间文件
```shell
cpp [options] main.c /tmp/main.i
```
- C编译器，将`main.i`翻译成ASCII码的汇编语言文件`main.s`
```shell
cc1 /tmp/main.i -Og [options] -o /tmp/main.s
```
- 汇编器，将`main.s`翻译成可重定位文件`main.o`
```shell
as [options] -o /tmp/main.o /tmp/main.s
```
- 链接器，将可重定位文件和必要的系统文件合并起来，行程可执行文件
```shell
ld -o prog [system object files] /tmp/main.o /tmp/sum.o
```
- 加载器，将文件`prog`的代码和数据复制到内存中
```
linux> ./prog
```
# 2 目标文件
静态链接器以一组目标文件为输入，生成一个完全链接、可以加载和运行执行的目标文件。链接器完成两个工作：
- 符号解析：将目标文件中的每个符号引用和每个符号定义(`函数、全局变量、静态变量等`)关联起来；
- 重定位：每个符号定义与内存位置关联起来。
一般目标文件分为三种：
1. 可重定位目标文件
2. 可执行目标文件
3. 共享目标文件
在Linux或者Unix系统中，使用`ELF`(Executable and Linkable Format)作为目标文件的格式，典型的格式如下：

![](./_image/2018-12-10-21-24-42.jpg)
- `.text`:已编译的机器代码；
- `.rodata`:只读数据；
- `.data`: 已经初始化的全局和静态C变量；
- `.bss`:  未初始化的全局和静态C变量；
- `.symtab`:存放程序中定义和引用的函数和全局变量信息的符号表；
- `.rel.text`: 可重定位的`.text`节位置的列表；
- `.rel.data`:引用和定义的全局变量可从重定位的信息。
- ...

# 3 符号和符号表
每个模块`m`都有一个符号表，包含了三种符号：
- 由模块`m`定义并且能够被其他模块引用的全局符号；
- 由其他模块定义能够被模块`m`引用的全局符号；
- 只有模块`m`定义和引用的局部符号；
本地非静态成员变量由栈管理，但是带有C static的本地过程变量不是有栈管理，而是在`.data`或者`.bss`中分配空间。
`.symtab`节包含了`ELF`文件中的符号表，包含了一个条目，每个条目格式如下
```C
typedef struct {
    int name;
    char type:4, binding 4;
    char reversed;
    short section;
    long value;
    long size;
} Elf64_Symbol;
```
- name: 字符串表中的偏移，以`\0`结尾；
- value: 符号的地址，可重定位目标文件，为该节的偏移；对于可执行目标文件，为绝对地址；
- size: 目标的大小；
- type: 符号类型，要么是数据，要么是函数；
- biding: 是本地的，还是全局；
- section: 所属的小节。

# 4 符号解析
对于相同模块的的局部符号的定义，编译器能够保证只有一个定义，但是对于全局符号的引用，编译器假定在其他模块中定义。但是链接器的所有输入模块都找不到该符号的定义，那么输出错误。
在所有输入模块中，会存在全局符号的多重定义，但是分为强弱符号（函数，初始化的全局变量为强符号；未初始化的全局变量为弱符号)。链接器的采取的规则如下：
- 不允许有多个同名的强符号；
- 一个强符号和多个弱符号，选择强符号；
- 多个弱符号，随机选择其中一个弱符号。

# 5 静态库
在程序开发中，都会使用其他已经完成的模块，比如系统调用`printf`,`scanf`等，或者数学函数`sin`,`sqrt`等。如果这些模块都是属于可重定位的目标文件，那么在编译的时候做好需要将他们添加进来，有两种解决方案：
1. 将相似的功能的函数放在同一个目标文件中，比如`libc.o`文件，那么编译执行命令`gcc main.c /usr/lib/libc.o`。该方法的缺点是通常`libc.o`文件非常大，每次都会拷贝一份副本到执行程序中，增加负担。
2. 将每一个函数生成相应的目标文件，比如`/usr/lib/printf.o`, `/usr/lib/cos.o`, 那么编译执行命令`gcc main.c /usr/lib/printf.o /usr/lib/cos.o`。该方法的缺陷是导致目标文件特别多，增加了编译命令参数的复杂度。

将具有相似功能的目标文件进行归档`archive`, 生成一个目标文件的集合，有一个头部信息描述包含的目标文件的详细信息，这个文件也叫做静态库，以`.a`作为后缀名。在编译的过程中，从静态库中只提取所需的目标文件，这样既减少了生成文件的大小，也减低了编译的复杂度。


