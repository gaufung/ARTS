---
date: 2019-03-19
status: public
tags: Tools
title: Go 语言学习笔记
---
# 1 类型
## 1.1 简短模式
- 定义变量，同时显示初始化
- 不能提供数据类型
- 只能用在函数内部

退化为赋值操作，当且仅当 `至少有一个新的变量被定义，切必须处于同一作用域`

## 1.2 常量
编译器能够计算出来的表达式，也有一作为常量
```go
const (
	ptrSize = unsafe.Sizeof(uintptr(0))
	strSize = len("hello, world!")
)
```
## 1.3 引用类型
预定义的引用类型 `slice, map, channel`，`new` 按照类型长度分配零值类型，返回指针，不关心内部构造和初始化方式；`make` 转换为目标类型专用的创建函数和指令，确保内存分配和相关属性初始化。

# 2 表达式
## 2.1 指针
- 并非所有的对象都可以取地址，但是变量总能正确返回
```go
m := map[string]int {"a": 1}
println(&m["a"]) //panic
```
- 零长度的（zero-size)对象地址与实现有关，不等于`nil`

## swith 语句
从上到下，从左到右匹配 `case` 语句，只有到最后才匹配 `default` 语句。

# 3 函数
## 3.1 函数定义
从函数返回局部变量的指针是安全的，编译器会使用逃逸分析(`escape analysis`) 来决定是否分配在堆上。
```go
func test() *int {
    a := 0x100
    return &a
}

func main(){
    var a *int = test()
    fmt.Println(a, *a)
}
```
## 3.1 参数
都是值拷贝传递（`pass-by-value`)，区别在于是拷贝目标对象，还是拷贝指针。
## 3.2 返回值命名
命令返回值让函数声明更加清晰，同事改善帮助文档。
## 3.2 闭包
闭包本质上是返回`funcval`对象，该对象包含了指向所引用的环境变量的指针。
## 3.3 延迟调用(`defer`)
执行步骤：
- 更新返回值
- 调用`defer`语句
- 执行`return`
`defer`包含了函数的注册、调用和额外的缓存开销。

# 4 数据
## 4.1 切片
`slice` 不是数组或者数组指针，它通过内部指针和相关属性应用数组片段
```c
struct Slice
{
  byte* array;
  uintgo len;
  uintgo cap;  
};
```
`reslice` 中 s[low:high:maxcap]

## 4.2 map 
map 因为扩张而重新哈希，因此 map 是 `not addressable`，通过类似 `m[1].name` 来修改是被禁止的
```go
type user struct { name string}
m := map[int]user {
    1: { "user1" },
}
m[1].name = "Tom" // error 
```
`map` 在迭代的过程中，也可以删除键值。

## 4.3 匿名字段
```go
type User struct {
    name string
}
type Manager struct {
    User
    title string
}
```
匿名字段是一种语法糖，创建了一个成员类型同名的字段。

# 5 方法
方法绑定对象实例，并且
